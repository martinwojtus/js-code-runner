(window.webpackJsonpJsCodeRunner=window.webpackJsonpJsCodeRunner||[]).push([[1],{"./vendor/sass/sass.js":
/*!*****************************!*\
  !*** ./vendor/sass/sass.js ***!
  \*****************************/
/*! no static exports found */function(module,exports,__webpack_require__){eval("/* WEBPACK VAR INJECTION */(function(__dirname) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;function _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\n/*! sass.js - v0.10.8 (eb28f5f) - built 2018-01-21\n  providing libsass 3.4.8 (a1f13edf)\n  via emscripten 1.37.0 ()\n */\n(function (root, factory) {\n  'use strict';\n\n  if (true) {\n    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?\n\t\t\t\t(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),\n\t\t\t\t__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));\n  } else {}\n})(this, function () {\n  /*global document*/\n  // identify the path sass.js is located at in case we're loaded by a simple\n  // <script src=\"path/to/sass.js\"><\/script>\n  // this path can be used to identify the location of\n  // * sass.worker.js from sass.js\n  // * libsass.js.mem from sass.sync.js\n  // see https://github.com/medialize/sass.js/pull/32#issuecomment-103142214\n  // see https://github.com/medialize/sass.js/issues/33\n  var SASSJS_RELATIVE_PATH = function () {\n    'use strict'; // in Node things are rather simple\n\n    if (true) {\n      return __dirname;\n    } // we can only run this test in the browser,\n    // so make sure we actually have a DOM to work with.\n\n\n    if (typeof document === 'undefined' || !document.getElementsByTagName) {\n      return null;\n    } // http://www.2ality.com/2014/05/current-script.html\n\n\n    var currentScript = document.currentScript || function () {\n      var scripts = document.getElementsByTagName('script');\n      return scripts[scripts.length - 1];\n    }();\n\n    var path = currentScript && currentScript.src;\n\n    if (!path) {\n      return null;\n    } // [worker] make sure we're not running in some concatenated thing\n\n\n    if (path.slice(-8) === '/sass.js') {\n      return path.slice(0, -8);\n    } // [sync] make sure we're not running in some concatenated thing\n\n\n    if (path.slice(-13) === '/sass.sync.js') {\n      return path.slice(0, -13);\n    }\n\n    return null;\n  }() || '.';\n  /*global Worker, SASSJS_RELATIVE_PATH*/\n\n\n  'use strict';\n\n  var noop = function noop() {};\n\n  var slice = [].slice; // defined upon first Sass.initialize() call\n\n  var globalWorkerUrl;\n\n  function Sass(workerUrl) {\n    if (!workerUrl && !globalWorkerUrl) {\n      /*jshint laxbreak:true */\n      throw new Error('Sass needs to be initialized with the URL of sass.worker.js - ' + 'either via Sass.setWorkerUrl(url) or by new Sass(url)');\n      /*jshint laxbreak:false */\n    }\n\n    if (!globalWorkerUrl) {\n      globalWorkerUrl = workerUrl;\n    } // bind all functions\n    // we're doing this because we used to have a single hard-wired instance that allowed\n    // [].map(Sass.removeFile) and we need to maintain that for now (at least until 1.0.0)\n\n\n    for (var key in this) {\n      if (typeof this[key] === 'function') {\n        this[key] = this[key].bind(this);\n      }\n    }\n\n    this._callbacks = {};\n    this._worker = new Worker(workerUrl || globalWorkerUrl);\n\n    this._worker.addEventListener('message', this._handleWorkerMessage, false);\n  } // allow setting the workerUrl before the first Sass instance is initialized,\n  // where registering the global workerUrl would've happened automatically\n\n\n  Sass.setWorkerUrl = function (workerUrl) {\n    globalWorkerUrl = workerUrl;\n  };\n\n  Sass.style = {\n    nested: 0,\n    expanded: 1,\n    compact: 2,\n    compressed: 3\n  };\n  Sass.comments = {\n    'none': 0,\n    'default': 1\n  };\n  Sass.prototype = {\n    style: Sass.style,\n    comments: Sass.comments,\n    destroy: function destroy() {\n      this._worker && this._worker.terminate();\n      this._worker = null;\n      this._callbacks = {};\n      this._importer = null;\n    },\n    _handleWorkerMessage: function _handleWorkerMessage(event) {\n      if (event.data.command) {\n        this[event.data.command](event.data.args);\n      }\n\n      this._callbacks[event.data.id] && this._callbacks[event.data.id](event.data.result);\n      delete this._callbacks[event.data.id];\n    },\n    _dispatch: function _dispatch(options, callback) {\n      if (!this._worker) {\n        throw new Error('Sass worker has been terminated');\n      }\n\n      options.id = 'cb' + Date.now() + Math.random();\n      this._callbacks[options.id] = callback;\n\n      this._worker.postMessage(options);\n    },\n    _importerInit: function _importerInit(args) {\n      // importer API done callback pushing results\n      // back to the worker\n      var done = function done(result) {\n        this._worker.postMessage({\n          command: '_importerFinish',\n          args: [result]\n        });\n      }.bind(this);\n\n      try {\n        this._importer(args[0], done);\n      } catch (e) {\n        done({\n          error: e.message\n        });\n        throw e;\n      }\n    },\n    importer: function importer(importerCallback, callback) {\n      if (typeof importerCallback !== 'function' && importerCallback !== null) {\n        throw new Error('importer callback must either be a function or null');\n      } // callback is executed in the main EventLoop\n\n\n      this._importer = importerCallback; // tell worker to activate importer callback\n\n      this._worker.postMessage({\n        command: 'importer',\n        args: [Boolean(importerCallback)]\n      });\n\n      callback && callback();\n    }\n  };\n  var commands = 'writeFile readFile listFiles removeFile clearFiles lazyFiles preloadFiles options compile compileFile';\n  commands.split(' ').forEach(function (command) {\n    Sass.prototype[command] = function () {\n      var callback = slice.call(arguments, -1)[0];\n      var args = slice.call(arguments, 0, -1);\n\n      if (typeof callback !== 'function') {\n        args.push(callback);\n        callback = noop;\n      }\n\n      this._dispatch({\n        command: command,\n        args: args\n      }, callback);\n    };\n  }); // automatically set the workerUrl in case we're loaded by a simple\n  // <script src=\"path/to/sass.js\"><\/script>\n  // see https://github.com/medialize/sass.js/pull/32#issuecomment-103142214\n\n  Sass.setWorkerUrl(SASSJS_RELATIVE_PATH + '/sass.worker.js');\n  return Sass;\n});\n/* WEBPACK VAR INJECTION */}.call(this, \"/\"))\n\n//# sourceURL=webpack://JsCodeRunner/./vendor/sass/sass.js?")}}]);